/* 
 * Names: Abraham Bhatti, David Lopez-Ryan, Sebastian Ortiz Ayala, Joy Zhu
 * Emails: abhatti@scu.edu, rlopezryan@scu.edu, sortizayala@scu.edu, jhzhu@scu.edu
 * Template implementation
*/

#include <iostream>
#include <iomanip>
#include <cstddef>
#include <stdexcept>
#include <string>
#include <string.h>
#include <new>

namespace csen79 {

// copy constructor
template <typename T>
Bag<T>::Bag(const Bag &rhs): data(nullptr), capacity(rhs.capacity), count(rhs.count), front(rhs.front), rear(rhs.rear), inject_new_fail(rhs.inject_new_fail) {
    if (capacity > 0) {
        data = new Data[capacity];
        throwNewFailure();
        for (std::size_t i = 0; i < count; ++i)
            data[i] = rhs.data[(front + i) % capacity];
    }
}

// destructor
template <typename T>
Bag<T>::~Bag() { delete[] data; }

// move constructor
template <typename T>
Bag<T>::Bag(Bag &&rhs): data(rhs.data), capacity(rhs.capacity), count(rhs.count), front(rhs.front), rear(rhs.rear), inject_new_fail(rhs.inject_new_fail) {
    rhs.data = nullptr;    // Taking care of the rhs variables after moving
    rhs.capacity = 0;
    rhs.count = 0;
    rhs.front = 0;
    rhs.rear = 0;
}

// copy operator
template <typename T>
Bag<T> &Bag<T>::operator=(const Bag &rhs) {
    if (this != &rhs) {
        delete[] data;
        data = nullptr;
        capacity = 0;
        count = 0;
        front = 0;
        rear = 0;

        if (rhs.capacity > 0) {
            capacity = rhs.capacity;
            count = rhs.count;
            front = rhs.front;
            rear = rhs.rear;
            data = new Data[capacity];
            throwNewFailure();
            for (std::size_t i = 0; i < count; ++i)
                data[i] = rhs.data[(front + i) % capacity];
        }
    }
    return *this;
}

// move operator
template <typename T>
Bag<T> &Bag<T>::operator=(Bag &&rhs) {
    if (this != &rhs) {
        delete[] data;

        data = rhs.data;
        capacity = rhs.capacity;
        count = rhs.count;
        front = rhs.front;
        rear = rhs.rear;
        inject_new_fail = rhs.inject_new_fail;

        rhs.data = nullptr;
        rhs.capacity = 0;
        rhs.count = 0;
        rhs.front = 0;
        rhs.rear = 0;
        rhs.inject_new_fail = false;
    }
    return *this;
}

// for simulating allocation failure
template <typename T>
void Bag<T>::throwNewFailure() {
    if (inject_new_fail) {
        delete[] data;
        data = nullptr;
        throw std::bad_alloc();
    }
}

// simple access functions
template <typename T>
bool Bag<T>::isEmpty() const { return count == 0; }

template <typename T>
bool Bag<T>::isFull() const { return count == capacity; }

template <typename T>
std::size_t Bag<T>::size() const { return count; }

template <typename T>
void Bag<T>::expandCapacity() {
    std::size_t oldCap = capacity;
    std::size_t newCapacity = (oldCap > 0) ? (oldCap * 2) : 1;

    Data *newData = new Data[newCapacity];
    throwNewFailure();

    for (std::size_t i = 0; i < count; ++i)
        newData[i] = data[(front + i) % oldCap];

    delete[] data;
    data = newData;
    capacity = newCapacity;
    front = 0;
    rear = count;
}

template <typename T>
void Bag<T>::enQ(const Data &d) {
    if (isFull())
        expandCapacity();

    if (data == nullptr) {
        data = new Data[capacity];
        throwNewFailure();
    }

    data[rear] = d;
    rear = (rear + 1) % capacity;
    ++count;
}

template <typename T>
typename Bag<T>::Data Bag<T>::deQ() {
    if (isEmpty())
        throw std::out_of_range("Cannot dequeue from empty Bag");

    Data frontVal = data[front];
    front = (front + 1) % capacity;
    --count;
    return frontVal;
}

template <typename T>
void Bag<T>::print() const {
    if (isEmpty()) {
        std::cout << "Bag is empty" << std::endl;
        return;
    }

    for (std::size_t i = 0; i < count; ++i)
        std::cout << data[(front + i) % capacity] << std::endl;
}

}  // namespace csen79
